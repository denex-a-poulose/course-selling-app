"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  body: () => requestBodyValidator_default,
  cookie: () => requestCookiesValidator_default,
  header: () => requestHeaderValidator_default,
  params: () => requestParamsValidator_default,
  query: () => requestQueryValidator_default
});
module.exports = __toCommonJS(src_exports);

// src/types/validation.ts
var HTTP_STATUS_BAD_REQUEST = 400;
var ALLOWED_TYPES = [
  "string",
  "number",
  "boolean",
  "array",
  "object",
  "email",
  "url",
  "custom-regex",
  "custom-function"
];

// src/validators/utils.ts
var isPresent = (value) => value !== void 0 && value !== null && value !== "";
var getValueFromNestedObject = (obj, path) => {
  const keys = path.replace(/\[(\d+)\]/g, ".$1").split(".");
  let result = obj;
  for (const key of keys) {
    result = result ? result[key] : void 0;
  }
  return result;
};
var validateValue = (key, value, types, { min, max, regex, customValidator }, errors, validatedData) => {
  let isValid = true;
  types.forEach((type) => {
    const minValue = typeof min === "number" ? min : min == null ? void 0 : min[type];
    const maxValue = typeof max === "number" ? max : max == null ? void 0 : max[type];
    if (minValue !== void 0 && (typeof minValue !== "number" || minValue < 0)) {
      errors.push(`Minimum value for ${key} must be a non-negative number`);
      isValid = false;
    }
    if (maxValue !== void 0 && (typeof maxValue !== "number" || maxValue < 0)) {
      errors.push(`Maximum value for ${key} must be a non-negative number`);
      isValid = false;
    }
    if (type === "string" && typeof value === "string") {
      if (minValue !== void 0 && value.length < minValue) {
        errors.push(
          `${key} type is ${type}, it should be at least ${minValue} characters`
        );
        isValid = false;
      }
      if (maxValue !== void 0 && value.length > maxValue) {
        errors.push(
          `${key} type is ${type}, it should be at most ${maxValue} characters`
        );
        isValid = false;
      }
    }
    if (type === "number" && typeof value === "number") {
      if (minValue !== void 0 && value < minValue) {
        errors.push(
          `${key} type is ${type}, it should be at least ${minValue}`
        );
        isValid = false;
      }
      if (maxValue !== void 0 && value > maxValue) {
        errors.push(`${key} type is ${type}, it should be at most ${maxValue}`);
        isValid = false;
      }
    }
    if (type === "array" && Array.isArray(value)) {
      if (minValue !== void 0 && value.length < minValue) {
        errors.push(
          `${key} type is ${type}, it should be at least ${minValue} items`
        );
        isValid = false;
      }
      if (maxValue !== void 0 && value.length > maxValue) {
        errors.push(
          `${key} type is ${type}, it should be at most ${maxValue} items`
        );
        isValid = false;
      }
    }
  });
  if (isValid && types.includes("custom-regex") && regex && !regex.test(value)) {
    errors.push(`${key} is invalid`);
    isValid = false;
  }
  if (isValid && customValidator && typeof customValidator === "function") {
    const customError = customValidator(value);
    if (customError) {
      errors.push(customError);
      isValid = false;
    }
  }
  if (isValid && errors.length === 0) {
    setValueInNestedObject(validatedData, key, value);
  }
};
var validateType = (key, value, types, errors) => {
  const typeValidators = {
    string: (val) => typeof val === "string",
    number: (val) => typeof val === "number",
    boolean: (val) => typeof val === "boolean",
    array: (val) => Array.isArray(val),
    object: (val) => typeof val === "object" && !Array.isArray(val),
    email: (val) => typeof val === "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val),
    url: (val) => isValidURL(val),
    "custom-regex": () => true,
    "custom-function": () => true
  };
  const isValid = types.some((t) => {
    var _a;
    return (_a = typeValidators[t]) == null ? void 0 : _a.call(typeValidators, value);
  });
  if (!isValid) {
    errors.push(`${key} should be a valid ${types.join(" or ")}`);
    return false;
  }
  return true;
};
var setValueInNestedObject = (obj, path, value) => {
  const keys = path.replace(/\[(\d+)\]/g, ".$1").split(".");
  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!current[key]) {
      current[key] = isNaN(Number(keys[i + 1])) ? {} : [];
    }
    current = current[key];
  }
  current[keys[keys.length - 1]] = value;
};
var convertToArray = (value) => {
  const parseValue = (item) => {
    const trimmedItem = item.trim();
    const parsedNumber = Number(trimmedItem);
    return isNaN(parsedNumber) ? trimmedItem : parsedNumber;
  };
  if (typeof value === "string") {
    const trimmedValue = value.trim();
    const hasBrackets = trimmedValue.startsWith("[") && trimmedValue.endsWith("]");
    const content = hasBrackets ? trimmedValue.slice(1, -1) : trimmedValue;
    return content.split(",").map(parseValue);
  }
  if (Array.isArray(value)) {
    return value.map(
      (item) => typeof item === "string" ? parseValue(item) : item
    );
  }
  return [parseValue(value.toString())];
};
var isValidURL = (urlString) => {
  try {
    new URL(urlString);
    return true;
  } catch (e) {
    return false;
  }
};

// src/validators/requestBodyValidator.ts
var reqBody = (rules) => {
  return (req, res, next) => {
    const errors = [];
    const validatedData = {};
    if (!rules || !Array.isArray(rules)) {
      errors.push("Validation rules are not properly defined.");
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    rules.forEach((rule) => {
      const {
        key,
        type,
        required = false,
        min,
        max,
        regex,
        customValidator
      } = rule;
      if (typeof key !== "string" || key.trim() === "") {
        errors.push(`Key "${key}" must be a non-empty string`);
        return;
      }
      const types = Array.isArray(type) ? type : [type];
      let validType = true;
      types.forEach((t) => {
        if (!ALLOWED_TYPES.includes(t)) {
          errors.push(
            `${t} is not a valid type. Allowed types are ${ALLOWED_TYPES.join(", ")}`
          );
          validType = false;
        }
      });
      if (!validType) return;
      const value = getValueFromNestedObject(req.body, key);
      if (required && !isPresent(value)) {
        errors.push(`${key} is required`);
        return;
      }
      if (!isPresent(value)) return;
      if (!validateType(key, value, types, errors)) return;
      validateValue(
        key,
        value,
        types,
        { min, max, regex, customValidator },
        errors,
        validatedData
      );
    });
    if (errors.length > 0) {
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    req.body = validatedData;
    next();
  };
};
var requestBodyValidator_default = reqBody;

// src/validators/requestQueryValidator.ts
var requestQueryValidator = (rules) => {
  return (req, res, next) => {
    const errors = [];
    const validatedData = {};
    if (!rules || !Array.isArray(rules)) {
      errors.push("Validation rules are not properly defined.");
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    rules.forEach((rule) => {
      let {
        key,
        type,
        required = false,
        min,
        max,
        regex,
        customValidator
      } = rule;
      if (typeof key !== "string" || key.trim() === "") {
        errors.push(`Key "${key}" must be a non-empty string`);
      }
      const types = Array.isArray(type) ? type : [type];
      let validType = true;
      types.forEach((t) => {
        if (!ALLOWED_TYPES.includes(t)) {
          errors.push(
            `${t} is not a valid type. Allowed types are ${ALLOWED_TYPES.join(
              ", "
            )}`
          );
          validType = false;
        }
      });
      if (!validType) return;
      let value = getValueFromNestedObject(req.query, key);
      if (required && !isPresent(value)) {
        errors.push(`${key} is required`);
        return;
      }
      if (!isPresent(value)) return;
      if (type == "number") {
        value = Number(value);
        if (isNaN(value)) {
          errors.push(`${key} should be a valid number`);
          return;
        }
      }
      if (type == "array") {
        value = convertToArray(value);
      }
      if (!validateType(key, value, types, errors)) return;
      validateValue(
        key,
        value,
        types,
        { min, max, regex, customValidator },
        errors,
        validatedData
      );
    });
    if (errors.length > 0) {
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    req.query = validatedData;
    next();
    return;
  };
};
var requestQueryValidator_default = requestQueryValidator;

// src/validators/requestParamsValidator.ts
var requestParamsValidator = (rules) => {
  return (req, res, next) => {
    const errors = [];
    const validatedData = {};
    if (!rules || !Array.isArray(rules)) {
      errors.push("Validation rules are not properly defined.");
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    rules.forEach((rule) => {
      let {
        key,
        type,
        required = false,
        min,
        max,
        regex,
        customValidator
      } = rule;
      if (typeof key !== "string" || key.trim() === "") {
        errors.push(`Key "${key}" must be a non-empty string`);
        return;
      }
      const types = Array.isArray(type) ? type : [type];
      let validType = true;
      types.forEach((t) => {
        if (!ALLOWED_TYPES.includes(t)) {
          errors.push(
            `${t} is not a valid type. Allowed types are ${ALLOWED_TYPES.join(
              ", "
            )}`
          );
          validType = false;
        }
      });
      if (!validType) return;
      let value = getValueFromNestedObject(req.params, key);
      if (required && !isPresent(value)) {
        errors.push(`${key} is required`);
        return;
      }
      if (!isPresent(value)) return;
      if (type == "number") {
        value = Number(value);
        if (isNaN(value)) {
          errors.push(`${key} should be a valid number`);
          return;
        }
      }
      if (type == "array") {
        value = value.split(",");
      }
      if (!validateType(key, value, types, errors)) return;
      validateValue(
        key,
        value,
        types,
        { min, max, regex, customValidator },
        errors,
        validatedData
      );
    });
    if (errors.length > 0) {
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    req.params = validatedData;
    next();
    return;
  };
};
var requestParamsValidator_default = requestParamsValidator;

// src/validators/requestHeaderValidator.ts
var requestHeaderValidator = (rules) => {
  return (req, res, next) => {
    const errors = [];
    const validatedData = {};
    if (!rules || !Array.isArray(rules)) {
      errors.push("Validation rules are not properly defined.");
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    rules.forEach((rule) => {
      const {
        key,
        type,
        required = false,
        min,
        max,
        regex,
        customValidator
      } = rule;
      if (typeof key !== "string" || key.trim() === "") {
        errors.push(`Key "${key}" must be a non-empty string`);
        return;
      }
      const types = Array.isArray(type) ? type : [type];
      let validType = true;
      types.forEach((t) => {
        if (!ALLOWED_TYPES.includes(t)) {
          errors.push(
            `${t} is not a valid type. Allowed types are ${ALLOWED_TYPES.join(
              ", "
            )}`
          );
          validType = false;
        }
      });
      if (!validType) return;
      const value = getValueFromNestedObject(req.headers, key);
      if (required && !isPresent(value)) {
        errors.push(`${key} is required`);
        return;
      }
      if (!isPresent(value)) return;
      if (!validateType(key, value, types, errors)) return;
      validateValue(
        key,
        value,
        types,
        { min, max, regex, customValidator },
        errors,
        validatedData
      );
    });
    if (errors.length > 0) {
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    next();
  };
};
var requestHeaderValidator_default = requestHeaderValidator;

// src/validators/requestCookiesValidator.ts
var requestCookiesValidator = (rules) => {
  return (req, res, next) => {
    const errors = [];
    const validatedData = {};
    if (!rules || !Array.isArray(rules)) {
      errors.push("Validation rules are not properly defined.");
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    rules.forEach((rule) => {
      const {
        key,
        type,
        required = false,
        min,
        max,
        regex,
        customValidator
      } = rule;
      if (typeof key !== "string" || key.trim() === "") {
        errors.push(`Key "${key}" must be a non-empty string`);
        return;
      }
      const types = Array.isArray(type) ? type : [type];
      let validType = true;
      types.forEach((t) => {
        if (!ALLOWED_TYPES.includes(t)) {
          errors.push(
            `${t} is not a valid type. Allowed types are ${ALLOWED_TYPES.join(
              ", "
            )}`
          );
          validType = false;
        }
      });
      if (!validType) return;
      const value = getValueFromNestedObject(req.cookies, key);
      if (required && !isPresent(value)) {
        errors.push(`${key} is required`);
        return;
      }
      if (!isPresent(value)) return;
      if (!validateType(key, value, types, errors)) return;
      validateValue(
        key,
        value,
        types,
        { min, max, regex, customValidator },
        errors,
        validatedData
      );
    });
    if (errors.length > 0) {
      return res.status(HTTP_STATUS_BAD_REQUEST).json({
        status: HTTP_STATUS_BAD_REQUEST,
        message: errors
      });
    }
    req.cookies = validatedData;
    next();
  };
};
var requestCookiesValidator_default = requestCookiesValidator;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  body,
  cookie,
  header,
  params,
  query
});
